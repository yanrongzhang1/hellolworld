object MonAfternoonTasks extends App {
  //Task 1

  val answer1_a = (3 + 4) * 57 < 300 //false
  val answer1_b = 144 / 12 >= 12 //true
  val answer1_c = "Cat" < "Dog" //true
  val answer1_d = "Rabbit" < "Hamster" //false
  val answer1_e = 17 % 2 != 0 //true
  val answer1_f = 75 / 9 < 30 && 89 / 6 < 20 //true

  println(answer1_a)
  println(answer1_b)
  println(answer1_c)
  println(answer1_d)
  println(answer1_e)
  println(answer1_f)

  //Task 2
  //  What is the difference between the `String` “I love scala already” and the print line “println (“I
  //  love scala already”)”?
  //answer:
  //  "I Love scala already" -  type is String,
  //  println (“I love scala already”) type is Unit, print out the string
  //

  //Task 3. Write a method to calculate the square of an
  //    `Int` return type.
  def squareInt(number: Int): Int = {
    number * number
  }

  println(squareInt(5)) //print 25

  //Task 4. Write a method to check if a number is odd. It should have an `Int` input parameter and
  //    `Boolean` return type.
  def isOddNumber(number: Int): Boolean = {
    number % 2 != 0
  }

  println(isOddNumber(10)) //false
  println(isOddNumber(11)) //true

  //Task 5. Consider a Library, there are many books. Write a Class called ‘Book’
  //. What class parameters
  //  will your book need? Can you include any class methods in the body? Can you consider type
  //  sensitivity in your class parameter(s) type(s) (and what needs to be made here if you do…)?

  // should be explicit with types for clarity and safety
  class Book(val title: String, val author: String, val publishDate: String, val price: Double) {
    def isNewbook(): Boolean = {
      publishDate >= "2025-01-01"
    }
  }

  val cyclist = new Book(title = "The Cyclist", author = "Tim Sullivan", publishDate = "2021-11-11", price = 9.19)
  println(cyclist.isNewbook()) //false
  //order of the parameters is wrong, so the output is wrong
  val cyclist1 = new Book("2021-11-11", "Tim Sullivan", "The Cyclist", price = 9.19)
  println(s"cyclist1 author is " + cyclist1.title) // "2021-11-11"

  //  Extension:
  //    1. Convert a lowercase `String` to uppercase.
  def convertToUpperCase(inputString: String): String = {
    inputString.toUpperCase()
  }

  println(convertToUpperCase("abc")) //ABC

  //  2. Convert the first letter of a `String` to uppercase.
  def firstLetterToUpperCase(inputString: String): String = {
    inputString.charAt(0).toUpper + inputString.substring(1)
  }

  println(s"first letter to upper case: " +  firstLetterToUpperCase("abc")) //Abc

  //  3. “STRING” == “string”
  //  Is this true or false? Why?
  //  false, because ascii code of uppercase letter is different from lowercase letter
  println("STRING" == "string")

  //  4. Can you simply convert the `String` “one” to the `Int` 1?
  //  No, they are different type
  //  you can convert each letter in the string to their ascii value
  //  def stringToInt(inputString: String): Int = {
  //    inputString.charAt(0).toInt
  //  }
  //  println(stringToInt("one")) // 111


  //    5. Can you simply convert the `Int` 1 to `String` “one”?
  // No, they are different type


  //  6. Can you simply convert `Int` 1 to type `String`? Is the result as you would expect?
  // yes you can, but it will be String "1"
  def intToString(number: Int): String = {
    number.toString
  }

  println(intToString(1)) // "1"

  //  Research:
  //  1. Make a val called new which is type string. Why doesn’t this compile?
  //  val new: String
  //because new is a key word which can't be used as a val name


  //  2. What do we need to do within our code to make it compile? Are there any other words that you
  //  cannot use?

  val new_val: String = "abc"
  //
  //  Keywords or Reserved words are the words in a language that are used for some internal process or represent some predefined actions.
  //  These words are therefore not allowed to use as variable names or objects.
  //  3. Investigate how a
  //  `
  //  case class` is different to a
  //  `
  //  class`
  //. When might you use each one?

  // when create a case class, don't need to use "new"
  //eg. val new_book = Book("author", "title" ...)
  // case class parameters are public val, don't need to add val to each parameter, they are immutable
  //instances of case classes are compared by structure and not by reference
  //you can create a (shallow) copy of an instances of a case class simply by using the copy method.
  // case class can be used in pattern matching because it has a companion object generated by the compiler

  //  usual class where constructor parameters are private by default
  //  they are compared by references
  //  although using case class help make the code clean and neat, but it has additional 20 methods generated by the compiler.

  //if you are modelling immutable data /you want to compare by structure/ you want to do pattern matching/ use copy, toString
  // methods, then use case class
  // otherwise use class



//answers

  //MVP
  //1a. Three plus four, times fifty-seven is less than three-hundred
  3 + 4 * 57 < 300
  //1b. One-hundred and forty-four, divided by 12 is greater than twelve or equal to twelve
  144 / 12 >= 12
  //1c. Cat is less than Dog (strings)
  "Cat" < "Dog"
  //1d. Rabbit is less than Hamster (strings)
  "rabbit" < "hamster"
  //1e. Seventeen is odd (modulus)
  17 % 2 != 0
  //1f. Seventy-five divided by nine is less than thirty and eighty-nine divided by six is less than twenty
  75 / 9 < 30 && 89 / 6 < 20

  //2. “I love scala already” - has a value of type string. It’s a string literal. Print line is an expression – a side effect as it prints to console – returns a unit (not a string!).

  //3.	Write a method to calculate the square of an `Int`. It should have an `Int` input parameter and `Int` return type.
  def newSquared (number: Int): Int = number * number

  //4.	Write a method to check if a number is odd. It should have an `Int` input parameter and `Boolean` return type.
  def isOdd(number: Int): Boolean  = number % 2 != 0

  //5. Consider a Library, there are many books. Write a Class called ‘Book’. What class parameters will your book need? Can you include any class methods in the body? Can you consider type sensitivity in your class parameter(s) type(s) (and what needs to be made here if you do…)?

  class Book1 (val title: Title, val genre: Genre, val pageCount:Int) {
    def read (x: Int) = s"I've read $x pages!"
  }
  class Title (title:String)
  class Genre (genre: String)

  //Object of type Book
  val newBook:Book1 = new Book1 (new Title("New Book"), new Genre("Horror"), 673)

  //Extension

  //1. Convert a lowercase string to uppercase.
  val uppercase = "hello".toUpperCase

  //2. Convert on the first letter of a string to uppercase.
  val onlyFirstLetter = "hello".capitalize

  //3. ”STRING” == “string” True or false? Why?
  val areYouEqual = "STRING" == "string"
  //No - case sensitive

  //4. Can you simply convert the `String` “one” to the `Int` 1?
  // Not simply (we can't just use .toInt). The compiler doesn't know that "one" is the same as 1. We would need to look at mapping to be able to do this, hold this thought.

  //5. Can you simply convert the `Int` 1 to `String` “one”?
  //No, same as above.

  //6. Can you simply convert `Int` 1 to type `String`? Is the result as you would expect?
  val convertToString = 1.toString
  //Gives "1" as a string. Not one.

  //Research
  //1. Make a val called new which is type string. Why doesn’t this compile? What do we need to do within our code to make it work? Are there any other words that you cannot use?

  // val new:String = "I'm a new string"
  // new is a keyword - this means it is protected. Use backticks if calling a val a keyword is unavoidable. lots of keywords, just look them up.
  //2. Use backticks
  val `new`:String = "I'm a new string"
  //other keywords include: object, if, abstract, class.... (search scala keywords online and you'll find a big list!)

  //3. In Scala, case class is typically used for modelling immutable data because it automatically generates useful methods like toString, equals, hashCode, and copy, making your code shorter and more readable. It also supports pattern matching, which is useful when working with collections or algebraic data types. In contrast, a regular class requires you to write more boilerplate code and is better suited for scenarios where you need mutable state or more complex behaviour. In general, use case class for simple data structures and class for logic-heavy or mutable components.

}